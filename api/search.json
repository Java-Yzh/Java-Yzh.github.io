[{"id":"cfba112d122acdd551a96bb15a87ba8b","title":"Design Patterns","content":"GoF设计模式设计模式是什么设计模式其实是在软件开发过程中经过经验积累和验证总结得出的一套通用代码设计方案，是踩在巨人的肩膀上总结的设计成课。\n如果熟悉了设计模式，当遇到类似的场景，我们可以快速地参考设计模式实现代码。不仅可以加速我们的编码速度，也提升了代码的可扩展性、可重用性与可维护性！\n设计模式的作用1.帮助我们快速解决常见问题：设计模式提供了解决特定软件设计问题的通用方法，拿来套上即用，例如单例模式、代理模式、责任链模式等等。\n2.提升代码可扩展性：设计模式通常考虑了软件的扩展性，将不同的功能和功能变化分离开来实现，使得未来添加新功能更加容易。\n3.提高代码可重用性：设计模式本身就是经验的总结，按照设计模式的思路，很多代码封装的很殿好，便于复用，减少重复工作。\n4.提升代码可维护性：通过使用设计模式，使得代码结构更加清晰，易于理解和维护。\n5.简化沟通成本：如果大家都熟悉设计模式，其实设计模式就是一种通用语言，通过设计就能明白其实现含义，有助于开发者之间更有效地沟通设计意图。\n6.提供最佳实践：它们是经验的总结，可以指导开发者避免常见陷阱，采用最佳实践。\n设计模式分类1.创建型模式(Creational Patterns)\n用于创健对象的模式，同时隐藏对象创建的逻辑，避免代码中出现大量new操作和复杂的创健逻辑。目的是解耦对象的创健和使用\n常用的有：单例模式、工厂模式、建造者模式。\n不常见的有：原型模式。\n2.结构型模式(Structural Patterns):\n用于处理对象组合的结构，关注类与对象的组合。目的是通过组合对象或类的方式，形成更大的结构。\n常用的有：适配器模式、桥接模式、组合模式、装饰器模式、代理模式。\n不常见的有：外观模式（门面模式）、享元模式。\n3.行为型模式(Behavioral Patterns):\n用于定义对象如何相互协作以完成单个对象无法单独实现的任务，目的是定义类和对象间的通信方式。\n常用的有：观察者模式、责任链模式、策略模式、模板模式、状态模式、迭代器模式。\n不常见的有：备忘录模式、命令模式、中介者模式、访问者模式、解释器模式。\n部分设计模式的应用示例1.创建型模式：\n单例模式：数据库连接池、线程池。\n工厂方法模式：日志记录器。\n建造者模式：复杂对象的分步构建，如HTML文档生成器。\n2.结构型模式：\n适配器摸式：旧系统的兼容升级。\n装饰器模式：动态为对象增加功能，如Java IO流。\n代理模式：实现访问控制，如RPC调用。\n3.行为型模式：\n观察者模式：事件驱动系统，如订阅-发布系统。\n责任链模式：日志级别过滤、请求处理链。\n策略模式：支付方式选择（如微信、支付宝、信用卡）。\n","slug":"GoF设计模式","date":"2024-12-07T03:31:52.270Z","categories_index":"Design Patterns","tags_index":"Design Patterns","author_index":"零六贰肆"},{"id":"0bfd72c698ef240dfe9fc1748b5eeac0","title":"Decorator Pattern","content":"装饰器模式装饰器模式是什么装饰器模式是一种结构型设计模式，用于在不改变现有类的情况下动态为其添加新的功能。通过将对象嵌套在装饰器中，可以实现功能扩展，同时保留原对象的行为。\n主要作用是给原始类增强功能，一般使用组合形式对原始类进行一定的扩展，并且可以将多个装饰器组合在一起，实现多个功能的叠加。（多个装饰器组合需要装饰类与原始类实现了同样的接口或继承同样的抽象类）\n装饰器模式的特点1.动态扩展：无需修改原始类的代码即可添加新功能。\n2.遵循开闭原则：对扩展开放，对修改关闭。\n3.灵活组合：装饰器可以嵌套组合，形成复杂的功能。\n常见使用场景1.需要动态扩展功能：对现有对象添加功能，但不希望通过继承方式。\n2.不同组合的功能需求：功能可以按需组合，而不需要创建大量子类。\n3.透明扩展：客户端无需了解对象是否被装饰过。\n典型场景1.日志系统：在日志系统中动态添加时间戳、日志级别等信息。\n2.网络编程：为网络流添加缓存、压缩、加密功能。\n实现方式装饰器模式通常由四部分组成：\n1.Component（组件接口）：定义了对象的接口，可以给这些对象动态地添加职责。所有具体组件和装饰器都实现这个接口。\n2.ConcreteComponent（具体组件）：实现了 Component 接口，定义了一个具体的对象，也可以说是装饰器模式的基本对象。它提供了装饰器所增强的基础功能。\n3.Decorator（装饰器抽象类）：也实现了 Component 接口，并包含一个对 Component 的引用（通常是通过构造函数传递），用于包装具体组件或其它装饰器。它定义了在具体装饰器中可以被重写的行为。此抽象类不是必须的；有时直接从 Component 继承的具体装饰器就足够了。\n4.ConcreteDecorator（具体装饰器）：扩展自 Decorator 类，负责给组件对象动态地添加职责。每个具体装饰器都可以提供额外的状态和行为，并且可以在调用前后操作其包装的组件对象。\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 定义一个组件接口interface Message &#123;    String getContent();&#125;// 具体组件类class SimpleMessage implements Message &#123;    private String content;    public SimpleMessage(String content) &#123;        this.content = content;    &#125;    @Override    public String getContent() &#123;        return content;    &#125;&#125;// 抽象装饰器类abstract class MessageDecorator implements Message &#123;    protected Message message;    public MessageDecorator(Message message) &#123;        this.message = message;    &#125;    @Override    public String getContent() &#123;        return message.getContent();    &#125;&#125;// 具体装饰器类 - 加粗装饰器class BoldDecorator extends MessageDecorator &#123;    public BoldDecorator(Message message) &#123;        super(message);    &#125;    @Override    public String getContent() &#123;        return &quot;&lt;b&gt;&quot; + super.getContent() + &quot;&lt;/b&gt;&quot;;    &#125;&#125;// 具体装饰器类 - 斜体装饰器class ItalicDecorator extends MessageDecorator &#123;    public ItalicDecorator(Message message) &#123;        super(message);    &#125;    @Override    public String getContent() &#123;        return &quot;&lt;i&gt;&quot; + super.getContent() + &quot;&lt;/i&gt;&quot;;    &#125;&#125;// 测试装饰器模式public class DecoratorTest &#123;    public static void main(String[] args) &#123;        Message simpleMessage = new SimpleMessage(&quot;Hello World!&quot;);        Message boldMessage = new BoldDecorator(simpleMessage);        Message italicBoldMessage = new ItalicDecorator(boldMessage);        System.out.println(italicBoldMessage.getContent());        // 输出: &lt;i&gt;&lt;b&gt;Hello World!&lt;/b&gt;&lt;/i&gt;    &#125;&#125;\n\n","slug":"装饰器模式详解","date":"2024-12-07T03:31:45.516Z","categories_index":"Design Patterns","tags_index":"Design Patterns","author_index":"零六贰肆"},{"id":"8036a700aebd79e808b6b9883f20311f","title":"Singleton Pattern","content":"单例模式详解单例模式是什么单例模式是一种创建型设计模式，他确保一个类在整个程序运行过程中只有一个实例，并提供全局访问点来获取该实例。\n单例模式的核心思想是：控制对象的实例化，防止创建多个实例，从而节省资源并保证行为一致性。\n单例模式的特点1.唯一性：类的实例在整个程序生命周期只有一个。\n2.全局访问：提供一个全局访问点，让所有代码可以访问同一个实例。\n3.延迟加载：可以延迟实例化，在需要时才创建实例（如懒汉式实现方式）。\n常见使用场景1.资源管理：需要共享的资源如数据库连接池、线程池等，确保只有一个实例管理这些资源。\n2.全局配置：用于保存程序的配置信息，所有模块都可以访问和使用同一个配置示例。\n3.日志记录器：在多线程或分布式环境中确保日志记录器唯一性。\n实现方式1.饿汉式\n1234567891011121314public class EagerSingleton &#123;    // 类加载时就初始化实例    private static final EagerSingleton instance = new EagerSingleton();    // 私有构造函数防止外部实例化    private EagerSingleton() &#123;&#125;    // 提供全局访问点    public static EagerSingleton getInstance() &#123;        return instance;    &#125;    // 其他业务方法...&#125;\n\n2.1懒汉式（未考虑线程安全）\n1234567891011121314151617public class LazySingleton &#123;    // 实例在第一次调用 getInstance 时创建    private static LazySingleton instance;    // 私有构造函数防止外部实例化    private LazySingleton() &#123;&#125;    // 提供全局访问点，不考虑线程安全    public static LazySingleton getInstance() &#123;        if (instance == null) &#123;            instance = new LazySingleton();        &#125;        return instance;    &#125;    // 其他业务方法...&#125;\n\n2.2懒汉式（使用同步方法实现线程安全）\n123456789101112131415public class ThreadSafeLazySingleton &#123;    private static ThreadSafeLazySingleton instance;    private ThreadSafeLazySingleton() &#123;&#125;    // 使用同步方法保证线程安全    public static synchronized ThreadSafeLazySingleton getInstance() &#123;        if (instance == null) &#123;            instance = new ThreadSafeLazySingleton();        &#125;        return instance;    &#125;    // 其他业务方法...&#125;\n\n2.3懒汉式（使用双重检查锁定实现线程安全）\n12345678910111213141516171819public class DoubleCheckedLockingSingleton &#123;    // volatile 关键字确保 instance 的可见性    private static volatile DoubleCheckedLockingSingleton instance;    private DoubleCheckedLockingSingleton() &#123;&#125;    public static DoubleCheckedLockingSingleton getInstance() &#123;        if (instance == null) &#123;            synchronized (DoubleCheckedLockingSingleton.class) &#123;                if (instance == null) &#123;                    instance = new DoubleCheckedLockingSingleton();                &#125;            &#125;        &#125;        return instance;    &#125;    // 其他业务方法...&#125;\n\n3.静态内部类（线程安全）\n1234567891011121314151617public class SingletonWithStaticInnerClass &#123;    // 私有构造函数防止外部实例化    private SingletonWithStaticInnerClass() &#123;&#125;    // 静态内部类，仅当调用 getInstance 时才加载    private static class SingletonHolder &#123;        private static final SingletonWithStaticInnerClass INSTANCE = new SingletonWithStaticInnerClass();    &#125;    // 提供全局访问点    public static SingletonWithStaticInnerClass getInstance() &#123;        return SingletonHolder.INSTANCE;    &#125;    // 其他业务方法...&#125;\n\n使用静态内部类的方式是一种懒加载的单例模式实现，它利用了Java的类加载机制确保线程安全，而不需要额外的同步代码。这种方式只有在第一次调用 getInstance 方法时才会加载内部类并初始化实例，因此是延迟加载且线程安全的。这种实现方式不仅实现了懒加载，而且由于JVM的类加载机制保证了线程安全性，所以不需要使用同步关键字或双重检查锁定。\n4.枚举单例\n12345678public enum EnumSingleton &#123;    INSTANCE;    // 可以添加其他属性和方法    public void someMethod() &#123;        // 方法实现...    &#125;&#125;\n\n枚举类型的单例模式是最简单、最安全的一种实现方式。根据《Effective Java》作者Joshua Bloch的说法，这是实现单例模式的最佳实践。枚举天生就支持序列化机制，并防止反射攻击，因为Java不允许通过反射创建新的枚举实例。使用枚举实现单例模式非常简洁，只需要定义一个枚举常量即可。由于枚举类型的特殊性，它天然就是线程安全的，并且可以防止反序列化或反射攻击创建新的实例。\n","slug":"单例模式详解","date":"2024-12-07T03:19:26.566Z","categories_index":"Design Patterns","tags_index":"Design Patterns","author_index":"零六贰肆"}]