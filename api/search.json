[{"id":"d18f6cf7ec850f9424c2daedf3d5426a","title":"test2","content":"","slug":"测试二","date":"2024-12-07T03:31:52.270Z","categories_index":"","tags_index":"","author_index":"零六贰肆"},{"id":"55569e11a71c2cbe7d64e1aa9885d18a","title":"test1","content":"","slug":"测试一","date":"2024-12-07T03:31:45.516Z","categories_index":"","tags_index":"","author_index":"零六贰肆"},{"id":"8036a700aebd79e808b6b9883f20311f","title":"Singleton Pattern","content":"单例模式详解单例模式是什么单例模式是一种创建型设计模式，他确保一个类在整个程序运行过程中只有一个实例，并提供全局访问点来获取该实例。\n单例模式的核心思想是：控制对象的实例化，防止创建多个实例，从而节省资源并保证行为一致性。\n单例模式的特点1.唯一性：类的实例在整个程序生命周期只有一个。\n2.全局访问：提供一个全局访问点，让所有代码可以访问同一个实例。\n3.延迟加载：可以延迟实例化，在需要时才创建实例（如懒汉式实现方式）。\n常见使用场景1.资源管理：需要共享的资源如数据库连接池、线程池等，确保只有一个实例管理这些资源。\n2.全局配置：用于保存程序的配置信息，所有模块都可以访问和使用同一个配置示例。\n3.日志记录器：在多线程或分布式环境中确保日志记录器唯一性。\n实现方式1.饿汉式\n1234567891011121314public class EagerSingleton &#123;    // 类加载时就初始化实例    private static final EagerSingleton instance = new EagerSingleton();    // 私有构造函数防止外部实例化    private EagerSingleton() &#123;&#125;    // 提供全局访问点    public static EagerSingleton getInstance() &#123;        return instance;    &#125;    // 其他业务方法...&#125;\n\n2.1懒汉式（未考虑线程安全）\n1234567891011121314151617public class LazySingleton &#123;    // 实例在第一次调用 getInstance 时创建    private static LazySingleton instance;    // 私有构造函数防止外部实例化    private LazySingleton() &#123;&#125;    // 提供全局访问点，不考虑线程安全    public static LazySingleton getInstance() &#123;        if (instance == null) &#123;            instance = new LazySingleton();        &#125;        return instance;    &#125;    // 其他业务方法...&#125;\n\n2.2懒汉式（使用同步方法实现线程安全）\n123456789101112131415public class ThreadSafeLazySingleton &#123;    private static ThreadSafeLazySingleton instance;    private ThreadSafeLazySingleton() &#123;&#125;    // 使用同步方法保证线程安全    public static synchronized ThreadSafeLazySingleton getInstance() &#123;        if (instance == null) &#123;            instance = new ThreadSafeLazySingleton();        &#125;        return instance;    &#125;    // 其他业务方法...&#125;\n\n2.3懒汉式（使用双重检查锁定实现线程安全）\n12345678910111213141516171819public class DoubleCheckedLockingSingleton &#123;    // volatile 关键字确保 instance 的可见性    private static volatile DoubleCheckedLockingSingleton instance;    private DoubleCheckedLockingSingleton() &#123;&#125;    public static DoubleCheckedLockingSingleton getInstance() &#123;        if (instance == null) &#123;            synchronized (DoubleCheckedLockingSingleton.class) &#123;                if (instance == null) &#123;                    instance = new DoubleCheckedLockingSingleton();                &#125;            &#125;        &#125;        return instance;    &#125;    // 其他业务方法...&#125;\n\n3.静态内部类（线程安全）\n1234567891011121314151617public class SingletonWithStaticInnerClass &#123;    // 私有构造函数防止外部实例化    private SingletonWithStaticInnerClass() &#123;&#125;    // 静态内部类，仅当调用 getInstance 时才加载    private static class SingletonHolder &#123;        private static final SingletonWithStaticInnerClass INSTANCE = new SingletonWithStaticInnerClass();    &#125;    // 提供全局访问点    public static SingletonWithStaticInnerClass getInstance() &#123;        return SingletonHolder.INSTANCE;    &#125;    // 其他业务方法...&#125;\n\n使用静态内部类的方式是一种懒加载的单例模式实现，它利用了Java的类加载机制确保线程安全，而不需要额外的同步代码。这种方式只有在第一次调用 getInstance 方法时才会加载内部类并初始化实例，因此是延迟加载且线程安全的。这种实现方式不仅实现了懒加载，而且由于JVM的类加载机制保证了线程安全性，所以不需要使用同步关键字或双重检查锁定。\n4.枚举单例\n12345678public enum EnumSingleton &#123;    INSTANCE;    // 可以添加其他属性和方法    public void someMethod() &#123;        // 方法实现...    &#125;&#125;\n\n枚举类型的单例模式是最简单、最安全的一种实现方式。根据《Effective Java》作者Joshua Bloch的说法，这是实现单例模式的最佳实践。枚举天生就支持序列化机制，并防止反射攻击，因为Java不允许通过反射创建新的枚举实例。使用枚举实现单例模式非常简洁，只需要定义一个枚举常量即可。由于枚举类型的特殊性，它天然就是线程安全的，并且可以防止反序列化或反射攻击创建新的实例。\n","slug":"单例模式详解","date":"2024-12-07T03:19:26.566Z","categories_index":"design patterns","tags_index":"design patterns","author_index":"零六贰肆"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post1$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server1$ hexo server\n\nMore info: Server\nGenerate static files1$ hexo generate\n\nMore info: Generating\nDeploy to remote sites1$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2024-12-05T01:12:06.144Z","categories_index":"","tags_index":"","author_index":"零六贰肆"}]